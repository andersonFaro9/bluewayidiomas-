<?php

namespace App\Http\Controllers\Checkout;

use App\Domains\Admin\User;
use App\Domains\Gateway\Shop;
use App\Domains\Gateway\Transaction;
use App\Exceptions\ErrorExternalIntegration;
use App\Exceptions\ErrorInvalidIntegration;
use App\Units\Job\CheckoutVerify;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\GuzzleException;
use Psr\Http\Message\ResponseInterface;

use function Php\prop;

/**
 * Trait Integrator
 *
 * @package App\Http\Controllers\Checkout
 */
trait Integrator
{
    /**
     * @var Client
     */
    private $client;

    /**
     * @return Client
     */
    private function client(): Client
    {
        if (!$this->client) {
            $this->client = new Client();
        }
        return $this->client;
    }

    /**
     * @param string $endpoint
     * @param array $query
     *
     * @return mixed|ResponseInterface
     * @throws GuzzleException
     */
    final protected function get(string $endpoint, array $query = [])
    {
        return $this->client()->request('GET', $endpoint, ['query' => $query]);
    }

    /**
     * @param User $user
     * @param array $query
     *
     * @return mixed|ResponseInterface
     * @throws GuzzleException
     */
    final protected function requestIntegration(User $user, array $query)
    {
        $url = $user->shop->url;

        // default is Shop::KIND_EASY_PAYMENT_GATEWAY
        $endpoint = "{$url}/API/cashier/v1/create";
        if ($user->shop->kind === Shop::KIND_DECTA) {
            $endpoint = "{$url}/API/cashier/v2/decta/create";
        }
        return $this->get($endpoint, $query);
    }

    /**
     * @param Transaction $transaction
     *
     * @return string
     * @throws GuzzleException
     */
    final protected function statusIntegration(Transaction $transaction): string
    {
        $user = $transaction->owner;
        $integration = $transaction->getValue('integration');

        $url = $user->shop->url;

        // default is Shop::KIND_EASY_PAYMENT_GATEWAY
        $endpoint = "{$url}/API/cashier/v1/status/{$integration}";
        if ($user->shop->kind === Shop::KIND_DECTA) {
            $endpoint = "{$url}/API/cashier/v2/decta/status/{$integration}";
        }

        $response = $this->get($endpoint);
        $content = json_decode($response->getBody(), true, 512, JSON_THROW_ON_ERROR);
        $status = prop($content, 'status');
        return strtolower($status);
    }

    /**
     * @param User $user
     * @param array $data
     * @param array $fields
     * @param callable $onSuccess
     *
     * @return array
     * @throws ErrorInvalidIntegration
     * @throws GuzzleException
     * @throws ErrorExternalIntegration
     */
    final protected function createIntegration(User $user, array $data, array $fields, callable $onSuccess): array
    {
        // get the origin
        $origin = prop($data, 'origin');
        // get the transaction id
        $transactionId = prop($data, 'id');
        // configure callback
        $callback = url("/checkout/confirm/{$transactionId}");

        // start query with origin and callback
        $query = ['origin' => $origin, 'callback' => $callback];
        // configure the fields to send
        foreach ($fields as $source => $target) {
            $query[$target['send']] = $data[$source];
        }

        // validate the blueway inputs
        $errors = $this->validateIntegrations($query);
        if (count($errors)) {
            throw new ErrorInvalidIntegration($errors);
        }

        try {
            // make the request to CRYPTOS
            $response = $this->requestIntegration($user, $query);
            $content = json_decode($response->getBody(), true, 512, JSON_THROW_ON_ERROR);
        } catch (ClientException $exception) {
            $response = $exception->getResponse();
            if (!$response) {
                throw new ErrorInvalidIntegration(['queryString' => $query]);
            }
            $content = json_decode($response->getBody(), true, 512, JSON_THROW_ON_ERROR);
        }

        // get the status
        $status = prop($content, 'status');
        $body = prop($content, 'data');

        // check status is error
        if ($status === 'error') {
            throw new ErrorExternalIntegration($body);
        }

        // check status is error
        if ($status === 'fail') {
            $details = $this->parseValidationMessage($fields, $body);
            throw new ErrorInvalidIntegration($details);
        }

        // extract URL and ID generated by CRYPTOS
        $url = prop($body, 'url');
        $integration = prop($body, 'id');

        // add items on data to create transaction
        $data['url'] = $url;
        $data['integration'] = $integration;

        // create the transaction
        $onSuccess($data);

        CheckoutVerify::attempt($transactionId);

        return ['transactionId' => $transactionId, 'url' => $url, 'origin' => $origin];
    }

    /**
     * @param $data
     *
     * @return array
     */
    protected function validateIntegrations(array $data): array
    {
        $errors = [];
        $origin = prop($data, 'origin');
        $length = strlen($origin);
        if ($length < 1 || $length > 250) {
            $errors['origin'] = 'The origin field must have a length between 1 and 250.';
        }
        $callback = prop($data, 'callback');
        $length = strlen($callback);
        if ($length < 10 || $length > 250) {
            $errors['callback'] = 'The callback field must have a length between 10 and 250.';
        }
        return $errors;
    }

    /**
     * @param array $fields
     * @param mixed $body
     *
     * @return array
     */
    protected function parseValidationMessage(array $fields, $body): array
    {
        $details = [];
        $origin = ['origin' => ['send' => 'origin', 'receive' => 'origin']];
        foreach (array_merge($fields, $origin) as $source => $target) {
            $property_path = $source;
            $message = prop($body, $target['receive']);
            if (!$message) {
                continue;
            }
            $details[] = ['property_path' => $property_path, 'message' => $message];
        }
        return $details;
    }
}
